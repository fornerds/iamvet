name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch: # 수동 실행 가능

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ubuntu
          # 환경 변수들
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          ADMIN_JWT_SECRET: ${{ secrets.ADMIN_JWT_SECRET }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}
          NEXT_PUBLIC_S3_BUCKET_NAME: ${{ secrets.NEXT_PUBLIC_S3_BUCKET_NAME }}
          NEXT_PUBLIC_AWS_REGION: ${{ secrets.NEXT_PUBLIC_AWS_REGION }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_BASE_URL: ${{ secrets.NEXT_PUBLIC_BASE_URL }}
          CORS_ORIGIN: ${{ secrets.CORS_ORIGIN }}
          KAKAO_CLIENT_ID: ${{ secrets.KAKAO_CLIENT_ID }}
          KAKAO_CLIENT_SECRET: ${{ secrets.KAKAO_CLIENT_SECRET }}
          KAKAO_REDIRECT_URI: ${{ secrets.KAKAO_REDIRECT_URI }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI: ${{ secrets.GOOGLE_REDIRECT_URI }}
          NAVER_CLIENT_ID: ${{ secrets.NAVER_CLIENT_ID }}
          NAVER_CLIENT_SECRET: ${{ secrets.NAVER_CLIENT_SECRET }}
          NAVER_REDIRECT_URI: ${{ secrets.NAVER_REDIRECT_URI }}
          NEXT_PUBLIC_NAVER_MAP_CLIENT_ID: ${{ secrets.NEXT_PUBLIC_NAVER_MAP_CLIENT_ID }}
          NAVER_MAP_CLIENT_SECRET: ${{ secrets.NAVER_MAP_CLIENT_SECRET }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_APP_PASSWORD: ${{ secrets.EMAIL_APP_PASSWORD }}
          USE_KAKAO_BUSINESS_API: ${{ secrets.USE_KAKAO_BUSINESS_API }}
          KAKAO_ALIMTALK_TEMPLATE_ID: ${{ secrets.KAKAO_ALIMTALK_TEMPLATE_ID }}
          NODE_ENV: production
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} << ENDSSH
            set -e
            
            # 프로젝트 디렉토리로 이동
            cd /home/ubuntu/iamvet
            
            # NVM 환경 로드
            export NVM_DIR="\$HOME/.nvm"
            [ -s "\$NVM_DIR/nvm.sh" ] && \. "\$NVM_DIR/nvm.sh"
            
            # 최신 코드 가져오기
            echo "=== Git Pull ==="
            # Git lock 파일 제거 (이전 프로세스가 비정상 종료된 경우)
            rm -f .git/index.lock .git/refs/heads/main.lock
            git fetch origin
            git reset --hard origin/main
            git clean -fd
            
            # 환경 변수 파일 생성
            echo "=== Creating .env.production ==="
            cat > .env.production << ENVEOF
            NODE_ENV=production
            NODE_TLS_REJECT_UNAUTHORIZED=0
            DATABASE_URL="$DATABASE_URL"
            JWT_SECRET="$JWT_SECRET"
            JWT_REFRESH_SECRET="$JWT_REFRESH_SECRET"
            ADMIN_JWT_SECRET="$ADMIN_JWT_SECRET"
            NEXTAUTH_SECRET="$NEXTAUTH_SECRET"
            NEXTAUTH_URL="$NEXTAUTH_URL"
            AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
            AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
            AWS_REGION="$AWS_REGION"
            AWS_S3_BUCKET_NAME="$AWS_S3_BUCKET_NAME"
            NEXT_PUBLIC_S3_BUCKET_NAME="$NEXT_PUBLIC_S3_BUCKET_NAME"
            NEXT_PUBLIC_AWS_REGION="$NEXT_PUBLIC_AWS_REGION"
            NEXT_PUBLIC_SITE_URL="$NEXT_PUBLIC_SITE_URL"
            NEXT_PUBLIC_API_URL="$NEXT_PUBLIC_API_URL"
            NEXT_PUBLIC_BASE_URL="$NEXT_PUBLIC_BASE_URL"
            CORS_ORIGIN="$CORS_ORIGIN"
            KAKAO_CLIENT_ID="$KAKAO_CLIENT_ID"
            KAKAO_CLIENT_SECRET="$KAKAO_CLIENT_SECRET"
            KAKAO_REDIRECT_URI="$KAKAO_REDIRECT_URI"
            GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID"
            GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET"
            GOOGLE_REDIRECT_URI="$GOOGLE_REDIRECT_URI"
            NAVER_CLIENT_ID="$NAVER_CLIENT_ID"
            NAVER_CLIENT_SECRET="$NAVER_CLIENT_SECRET"
            NAVER_REDIRECT_URI="$NAVER_REDIRECT_URI"
            NEXT_PUBLIC_NAVER_MAP_CLIENT_ID="$NEXT_PUBLIC_NAVER_MAP_CLIENT_ID"
            NAVER_MAP_CLIENT_SECRET="$NAVER_MAP_CLIENT_SECRET"
            SMTP_HOST="$SMTP_HOST"
            SMTP_PORT="$SMTP_PORT"
            SMTP_USER="$SMTP_USER"
            SMTP_PASS="$SMTP_PASS"
            SMTP_FROM="$SMTP_FROM"
            EMAIL_USER="$EMAIL_USER"
            EMAIL_APP_PASSWORD="$EMAIL_APP_PASSWORD"
            USE_KAKAO_BUSINESS_API="$USE_KAKAO_BUSINESS_API"
            KAKAO_ALIMTALK_TEMPLATE_ID="$KAKAO_ALIMTALK_TEMPLATE_ID"
            ENVEOF
            
            # 의존성 설치
            echo "=== Installing Dependencies ==="
            npm ci --production=false
            
            # Prisma 클라이언트 생성
            echo "=== Generating Prisma Client ==="
            npx prisma generate
            
            # Prisma 마이그레이션 실행
            echo "=== Running Migrations ==="
            npx prisma migrate deploy || echo "Migration failed, continuing..."
            
            # 이전 빌드 캐시 완전히 삭제
            echo "=== Cleaning Previous Build ==="
            rm -rf .next
            rm -rf node_modules/.cache
            rm -rf .next/cache
            rm -rf .swc
            # PM2가 사용 중인 파일이 있을 수 있으므로 강제 삭제
            find .next -type f -delete 2>/dev/null || true
            find .next -type d -delete 2>/dev/null || true
            echo "✅ 빌드 캐시 삭제 완료"
            
            # Next.js 빌드
            echo "=== Building Next.js Application ==="
            npm run build
            
            # 빌드 결과 확인
            echo "=== Verifying Build ==="
            if [ ! -d ".next" ]; then
              echo "❌ 오류: .next 디렉토리가 생성되지 않았습니다."
              exit 1
            fi
            echo "✅ 빌드 완료 확인"
            
            # ecosystem.config.js 파일 생성 (항상 최신으로 업데이트)
            echo "=== Creating ecosystem.config.js ==="
            mkdir -p logs
            cat > ecosystem.config.js << 'ECOSYSTEMEOF'
            const fs = require('fs');
            const path = require('path');
            
            const envPath = path.join(__dirname, '.env.production');
            let envVars = {};
            
            if (fs.existsSync(envPath)) {
              const envFile = fs.readFileSync(envPath, 'utf8');
              envFile.split('\n').forEach(line => {
                const match = line.match(/^([^=]+)=(.*)$/);
                if (match) {
                  const key = match[1].trim();
                  const value = match[2].trim().replace(/^["']|["']$/g, '');
                  envVars[key] = value;
                }
              });
            }
            
            const nodeBinPath = path.join(__dirname, 'node_modules', '.bin');
            const nextPath = path.join(nodeBinPath, 'next');
            
            module.exports = {
              apps: [{
                name: 'iamvet',
                script: nextPath,
                args: 'start',
                cwd: '/home/ubuntu/iamvet',
                instances: 1,
                exec_mode: 'fork',
                env: {
                  NODE_ENV: 'production',
                  PORT: 3000,
                  HOSTNAME: '0.0.0.0',
                  PATH: process.env.PATH + ':' + nodeBinPath,
                  ...envVars
                },
                error_file: '/home/ubuntu/iamvet/logs/pm2-error.log',
                out_file: '/home/ubuntu/iamvet/logs/pm2-out.log',
                log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
                merge_logs: true,
                autorestart: true,
                max_memory_restart: '1G',
                watch: false,
                ignore_watch: ['node_modules', 'logs', '.next'],
                min_uptime: '10s',
                max_restarts: 10
              }]
            };
            ECOSYSTEMEOF
            
            # PM2 재시작
            echo "=== Restarting PM2 ==="
            if pm2 list | grep -q iamvet; then
              echo "기존 PM2 프로세스 중지 중..."
              pm2 stop iamvet || true
              pm2 delete iamvet || true
              
              # PM2 프로세스가 완전히 중지될 때까지 대기
              echo "PM2 프로세스 중지 대기 중..."
              MAX_WAIT=30  # 최대 30초 대기
              WAIT_COUNT=0
              while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
                if ! pm2 list | grep -q iamvet; then
                  echo "✅ PM2 프로세스가 완전히 중지되었습니다."
                  break
                fi
                echo "대기 중... ($WAIT_COUNT/$MAX_WAIT 초)"
                sleep 1
                WAIT_COUNT=$((WAIT_COUNT + 1))
              done
              
              # 타임아웃 체크
              if [ $WAIT_COUNT -eq $MAX_WAIT ]; then
                echo "⚠️ 경고: PM2 프로세스가 30초 내에 중지되지 않았습니다. 강제 종료를 시도합니다."
                pm2 kill 2>/dev/null || true
                sleep 3
                # PM2 데몬 재시작
                pm2 resurrect 2>/dev/null || true
                pm2 save 2>/dev/null || true
              fi
              
              # 추가 안전 대기
              sleep 3
            fi
            
            echo "새 PM2 프로세스 시작 중..."
            # PM2 완전히 정리 후 시작
            pm2 flush || true
            pm2 start ecosystem.config.js
            
            # 프로세스 시작 대기
            sleep 15
            
            # PM2 상태 확인
            pm2 status
            pm2 save
            
            # 프로세스가 정상적으로 시작되었는지 확인
            if pm2 list | grep -q "iamvet.*online"; then
              echo "✅ PM2 프로세스가 정상적으로 시작되었습니다."
              # 추가 확인: 실제로 서버가 응답하는지 테스트
              sleep 5
              if curl -f http://localhost:3000 > /dev/null 2>&1; then
                echo "✅ Next.js 서버가 정상적으로 응답합니다."
              else
                echo "⚠️ 경고: PM2는 실행 중이지만 서버가 응답하지 않습니다."
                pm2 logs iamvet --lines 30 --nostream
              fi
            else
              echo "❌ 경고: PM2 프로세스가 정상적으로 시작되지 않았습니다."
              pm2 logs iamvet --lines 30 --nostream
              exit 1
            fi
            
            echo "=== Setting up Auto-Recovery System ==="
            
            # 자동 복구 시스템 설정
            if [ ! -f "/home/ubuntu/iamvet/health-check.sh" ]; then
              echo "자동 복구 시스템 설정 중..."
              
              # 헬스체크 스크립트 생성
              cat > /home/ubuntu/iamvet/health-check.sh << 'HEALTHCHECK'
            #!/bin/bash
            
            # Next.js 서버 헬스체크 스크립트
            MAX_RESPONSE_TIME=5
            RETRY_COUNT=3
            
            for i in $(seq 1 $RETRY_COUNT); do
                if curl -f -s --max-time $MAX_RESPONSE_TIME http://localhost:3000 > /dev/null 2>&1; then
                    echo "$(date): ✅ Next.js 서버 정상 응답"
                    exit 0
                fi
                echo "$(date): ⚠️ 시도 $i/$RETRY_COUNT 실패, 재시도 중..."
                sleep 2
            done
            
            echo "$(date): ❌ Next.js 서버 응답 없음, PM2 재시작 시도"
            
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
            
            cd /home/ubuntu/iamvet
            pm2 restart iamvet
            
            sleep 10
            if curl -f -s --max-time $MAX_RESPONSE_TIME http://localhost:3000 > /dev/null 2>&1; then
                echo "$(date): ✅ PM2 재시작 후 서버 정상 응답"
                exit 0
            else
                echo "$(date): ❌ PM2 재시작 후에도 서버 응답 없음"
                exit 1
            fi
            HEALTHCHECK
              
              chmod +x /home/ubuntu/iamvet/health-check.sh
              
              # Cron job 설정 (기존 제거 후 추가)
              crontab -l 2>/dev/null | grep -v "health-check.sh" | crontab - 2>/dev/null || true
              (crontab -l 2>/dev/null; echo "*/5 * * * * /home/ubuntu/iamvet/health-check.sh >> /home/ubuntu/iamvet/logs/health-check.log 2>&1") | crontab -
              
              echo "✅ 자동 복구 시스템 설정 완료"
            else
              echo "✅ 자동 복구 시스템 이미 설정됨"
            fi
            
            echo "=== Deployment Complete ==="
          ENDSSH

      - name: Health Check
        run: |
          sleep 10
          # HTTP와 HTTPS 모두 확인
          curl -f http://${{ secrets.EC2_HOST }} || echo "HTTP check failed, trying HTTPS..."
          curl -f -k https://${{ secrets.EC2_HOST }} || echo "HTTPS check failed"

