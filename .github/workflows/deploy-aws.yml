name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch: # ÏàòÎèô Ïã§Ìñâ Í∞ÄÎä•

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Validate Secrets
        run: |
          if [ -z "${{ secrets.DATABASE_URL }}" ]; then
            echo "‚ùå DATABASE_URL SecretÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§!"
            echo "GitHub Ï†ÄÏû•ÏÜåÏùò Settings > Secrets and variables > ActionsÏóêÏÑú DATABASE_URLÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî."
            exit 1
          fi
          echo "‚úÖ ÌïÑÏàò Secrets ÌôïÏù∏ ÏôÑÎ£å"
      
      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ubuntu
          # ÌôòÍ≤Ω Î≥ÄÏàòÎì§
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          ADMIN_JWT_SECRET: ${{ secrets.ADMIN_JWT_SECRET }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}
          NEXT_PUBLIC_S3_BUCKET_NAME: ${{ secrets.NEXT_PUBLIC_S3_BUCKET_NAME }}
          NEXT_PUBLIC_AWS_REGION: ${{ secrets.NEXT_PUBLIC_AWS_REGION }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_BASE_URL: ${{ secrets.NEXT_PUBLIC_BASE_URL }}
          CORS_ORIGIN: ${{ secrets.CORS_ORIGIN }}
          KAKAO_CLIENT_ID: ${{ secrets.KAKAO_CLIENT_ID }}
          KAKAO_CLIENT_SECRET: ${{ secrets.KAKAO_CLIENT_SECRET }}
          KAKAO_REDIRECT_URI: ${{ secrets.KAKAO_REDIRECT_URI }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI: ${{ secrets.GOOGLE_REDIRECT_URI }}
          NAVER_CLIENT_ID: ${{ secrets.NAVER_CLIENT_ID }}
          NAVER_CLIENT_SECRET: ${{ secrets.NAVER_CLIENT_SECRET }}
          NAVER_REDIRECT_URI: ${{ secrets.NAVER_REDIRECT_URI }}
          NEXT_PUBLIC_NAVER_MAP_CLIENT_ID: ${{ secrets.NEXT_PUBLIC_NAVER_MAP_CLIENT_ID }}
          NAVER_MAP_CLIENT_SECRET: ${{ secrets.NAVER_MAP_CLIENT_SECRET }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_APP_PASSWORD: ${{ secrets.EMAIL_APP_PASSWORD }}
          USE_KAKAO_BUSINESS_API: ${{ secrets.USE_KAKAO_BUSINESS_API }}
          KAKAO_ALIMTALK_TEMPLATE_ID: ${{ secrets.KAKAO_ALIMTALK_TEMPLATE_ID }}
          NODE_ENV: production
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} << ENDSSH
            set -e
            
            # ÌîÑÎ°úÏ†ùÌä∏ ÎîîÎ†âÌÜ†Î¶¨Î°ú Ïù¥Îèô
            cd /home/ubuntu/iamvet
            
            # NVM ÌôòÍ≤Ω Î°úÎìú
            export NVM_DIR="\$HOME/.nvm"
            [ -s "\$NVM_DIR/nvm.sh" ] && \. "\$NVM_DIR/nvm.sh"
            
            # ÏµúÏã† ÏΩîÎìú Í∞ÄÏ†∏Ïò§Í∏∞
            echo "=== Git Pull ==="
            # Git lock ÌååÏùº Ï†úÍ±∞ (Ïù¥Ï†Ñ ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä ÎπÑÏ†ïÏÉÅ Ï¢ÖÎ£åÎêú Í≤ΩÏö∞)
            rm -f .git/index.lock .git/refs/heads/main.lock
            git fetch origin
            git reset --hard origin/main
            git clean -fd
            
            # ÌôòÍ≤Ω Î≥ÄÏàò ÌååÏùº ÏÉùÏÑ±
            echo "=== Creating .env.production ==="
            
            # DATABASE_URL Í≤ÄÏ¶ù
            if [ -z "$DATABASE_URL" ]; then
              echo "‚ùå Ïò§Î•ò: DATABASE_URL SecretÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§!"
              echo "GitHub Ï†ÄÏû•ÏÜåÏùò Settings > Secrets and variables > ActionsÏóêÏÑú DATABASE_URLÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî."
              exit 1
            fi
            
            # DATABASE_URL ÌòïÏãù Í≤ÄÏ¶ù
            if ! echo "$DATABASE_URL" | grep -qE "^postgresql://"; then
              echo "‚ö†Ô∏è Í≤ΩÍ≥†: DATABASE_URLÏù¥ Ïò¨Î∞îÎ•∏ ÌòïÏãùÏù¥ ÏïÑÎãê Ïàò ÏûàÏäµÎãàÎã§"
            fi
            
            echo "‚úÖ DATABASE_URL Secret ÌôïÏù∏Îê® (Í∞íÏùÄ Î≥¥ÏïàÏÉÅ ÌëúÏãúÌïòÏßÄ ÏïäÏùå)"
            
            # DATABASE_URLÏóê Ïó∞Í≤∞ ÌíÄ ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞Ä (ÏóÜÎäî Í≤ΩÏö∞)
            FINAL_DATABASE_URL="$DATABASE_URL"
            if echo "$DATABASE_URL" | grep -vq "connection_limit"; then
              if echo "$DATABASE_URL" | grep -q "?"; then
                FINAL_DATABASE_URL="$DATABASE_URL&connection_limit=10&pool_timeout=20&connect_timeout=10"
              else
                FINAL_DATABASE_URL="$DATABASE_URL?connection_limit=10&pool_timeout=20&connect_timeout=10"
              fi
              echo "‚úÖ DATABASE_URLÏóê Ïó∞Í≤∞ ÌíÄ ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞ÄÎê®"
            else
              echo "‚úÖ DATABASE_URLÏóê Ïù¥ÎØ∏ Ïó∞Í≤∞ ÌíÄ ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÏûàÏäµÎãàÎã§"
            fi
            
            cat > .env.production << ENVEOF
            NODE_ENV=production
            NODE_TLS_REJECT_UNAUTHORIZED=0
            DATABASE_URL="$FINAL_DATABASE_URL"
            JWT_SECRET="$JWT_SECRET"
            JWT_REFRESH_SECRET="$JWT_REFRESH_SECRET"
            ADMIN_JWT_SECRET="$ADMIN_JWT_SECRET"
            NEXTAUTH_SECRET="$NEXTAUTH_SECRET"
            NEXTAUTH_URL="$NEXTAUTH_URL"
            AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
            AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
            AWS_REGION="$AWS_REGION"
            AWS_S3_BUCKET_NAME="$AWS_S3_BUCKET_NAME"
            NEXT_PUBLIC_S3_BUCKET_NAME="$NEXT_PUBLIC_S3_BUCKET_NAME"
            NEXT_PUBLIC_AWS_REGION="$NEXT_PUBLIC_AWS_REGION"
            NEXT_PUBLIC_SITE_URL="$NEXT_PUBLIC_SITE_URL"
            NEXT_PUBLIC_API_URL="$NEXT_PUBLIC_API_URL"
            NEXT_PUBLIC_BASE_URL="$NEXT_PUBLIC_BASE_URL"
            CORS_ORIGIN="$CORS_ORIGIN"
            KAKAO_CLIENT_ID="$KAKAO_CLIENT_ID"
            KAKAO_CLIENT_SECRET="$KAKAO_CLIENT_SECRET"
            KAKAO_REDIRECT_URI="$KAKAO_REDIRECT_URI"
            GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID"
            GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET"
            GOOGLE_REDIRECT_URI="$GOOGLE_REDIRECT_URI"
            NAVER_CLIENT_ID="$NAVER_CLIENT_ID"
            NAVER_CLIENT_SECRET="$NAVER_CLIENT_SECRET"
            NAVER_REDIRECT_URI="$NAVER_REDIRECT_URI"
            NEXT_PUBLIC_NAVER_MAP_CLIENT_ID="$NEXT_PUBLIC_NAVER_MAP_CLIENT_ID"
            NAVER_MAP_CLIENT_SECRET="$NAVER_MAP_CLIENT_SECRET"
            SMTP_HOST="$SMTP_HOST"
            SMTP_PORT="$SMTP_PORT"
            SMTP_USER="$SMTP_USER"
            SMTP_PASS="$SMTP_PASS"
            SMTP_FROM="$SMTP_FROM"
            EMAIL_USER="$EMAIL_USER"
            EMAIL_APP_PASSWORD="$EMAIL_APP_PASSWORD"
            USE_KAKAO_BUSINESS_API="$USE_KAKAO_BUSINESS_API"
            KAKAO_ALIMTALK_TEMPLATE_ID="$KAKAO_ALIMTALK_TEMPLATE_ID"
            ENVEOF
            
            # ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò (Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî)
            echo "=== Installing Dependencies ==="
            # Î©îÎ™®Î¶¨ Î∂ÄÏ°± Î∞©ÏßÄÎ•º ÏúÑÌï¥ Í∏∞Ï°¥ node_modules Ïú†ÏßÄ
            if [ -d "node_modules" ]; then
              echo "Í∏∞Ï°¥ node_modules Ïú†ÏßÄ, ÏóÖÎç∞Ïù¥Ìä∏Îßå ÏàòÌñâ..."
              npm install --production=false --prefer-offline --no-audit
            else
              echo "node_modules ÏóÜÏùå, ÏÉàÎ°ú ÏÑ§Ïπò (Î©îÎ™®Î¶¨ Ï†úÌïú Ï†ÅÏö©)..."
              # Î©îÎ™®Î¶¨ Ï†úÌïúÏùÑ ÎëêÍ≥† ÏÑ§Ïπò (t3.largeÎäî Î©îÎ™®Î¶¨ Ïó¨Ïú†Í∞Ä ÏûàÏùå)
              NODE_OPTIONS="--max-old-space-size=2048" npm install --production=false --no-audit
            fi
            
            # Prisma ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
            echo "=== Generating Prisma Client ==="
            npx prisma generate
            
            # Prisma ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìñâ
            echo "=== Running Migrations ==="
            npx prisma migrate deploy || echo "Migration failed, continuing..."
            
            # Ïù¥Ï†Ñ ÎπåÎìú Ï∫êÏãú ÏôÑÏ†ÑÌûà ÏÇ≠Ï†ú
            echo "=== Cleaning Previous Build ==="
            rm -rf .next
            rm -rf node_modules/.cache
            rm -rf .next/cache
            rm -rf .swc
            # PM2Í∞Ä ÏÇ¨Ïö© Ï§ëÏù∏ ÌååÏùºÏù¥ ÏûàÏùÑ Ïàò ÏûàÏúºÎØÄÎ°ú Í∞ïÏ†ú ÏÇ≠Ï†ú
            find .next -type f -delete 2>/dev/null || true
            find .next -type d -delete 2>/dev/null || true
            echo "‚úÖ ÎπåÎìú Ï∫êÏãú ÏÇ≠Ï†ú ÏôÑÎ£å"
            
            # Next.js ÎπåÎìú (Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî)
            echo "=== Building Next.js Application ==="
            # Î©îÎ™®Î¶¨ Ï†úÌïúÏùÑ ÎëêÍ≥† ÎπåÎìú (t3.largeÎäî Î©îÎ™®Î¶¨ Ïó¨Ïú†Í∞Ä ÏûàÏùå)
            NODE_OPTIONS="--max-old-space-size=4096" npm run build
            
            # ÎπåÎìú Í≤∞Í≥º ÌôïÏù∏
            echo "=== Verifying Build ==="
            if [ ! -d ".next" ]; then
              echo "‚ùå Ïò§Î•ò: .next ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏÉùÏÑ±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."
              exit 1
            fi
            echo "‚úÖ ÎπåÎìú ÏôÑÎ£å ÌôïÏù∏"
            
            # ecosystem.config.js ÌååÏùº ÏÉùÏÑ± (Ìï≠ÏÉÅ ÏµúÏã†ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏)
            echo "=== Creating ecosystem.config.js ==="
            mkdir -p logs
            cat > ecosystem.config.js << 'ECOSYSTEMEOF'
            const fs = require('fs');
            const path = require('path');
            
            const envPath = path.join(__dirname, '.env.production');
            let envVars = {};
            
            if (fs.existsSync(envPath)) {
              const envFile = fs.readFileSync(envPath, 'utf8');
              envFile.split('\n').forEach(line => {
                const match = line.match(/^([^=]+)=(.*)$/);
                if (match) {
                  const key = match[1].trim();
                  const value = match[2].trim().replace(/^["']|["']$/g, '');
                  envVars[key] = value;
                }
              });
            }
            
            const nodeBinPath = path.join(__dirname, 'node_modules', '.bin');
            const nextPath = path.join(nodeBinPath, 'next');
            
            module.exports = {
              apps: [{
                name: 'iamvet',
                script: nextPath,
                args: 'start',
                cwd: '/home/ubuntu/iamvet',
                instances: 1,
                exec_mode: 'fork',
                env: {
                  NODE_ENV: 'production',
                  PORT: 3000,
                  HOSTNAME: '0.0.0.0',
                  PATH: process.env.PATH + ':' + nodeBinPath,
                  ...envVars
                },
                error_file: '/home/ubuntu/iamvet/logs/pm2-error.log',
                out_file: '/home/ubuntu/iamvet/logs/pm2-out.log',
                log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
                merge_logs: true,
                autorestart: true,
                max_memory_restart: '3G',  // t3.large (8GB) ÏóÖÍ∑∏Î†àÏù¥Îìú ÌõÑ Î©îÎ™®Î¶¨ Ï†úÌïú Ï¶ùÍ∞Ä
                node_args: '--max-old-space-size=3072',  // Node.js Ìûô Î©îÎ™®Î¶¨ Ï†úÌïú (3GB)
                watch: false,
                ignore_watch: ['node_modules', 'logs', '.next'],
                min_uptime: '10s',
                max_restarts: 10
              }]
            };
            ECOSYSTEMEOF
            
            # PM2 Ïû¨ÏãúÏûë
            echo "=== Restarting PM2 ==="
            if pm2 list | grep -q iamvet; then
              echo "Í∏∞Ï°¥ PM2 ÌîÑÎ°úÏÑ∏Ïä§ Ï§ëÏßÄ Ï§ë..."
              pm2 stop iamvet || true
              pm2 delete iamvet || true
              
              # PM2 ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä ÏôÑÏ†ÑÌûà Ï§ëÏßÄÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
              echo "PM2 ÌîÑÎ°úÏÑ∏Ïä§ Ï§ëÏßÄ ÎåÄÍ∏∞ Ï§ë..."
              MAX_WAIT=30  # ÏµúÎåÄ 30Ï¥à ÎåÄÍ∏∞
              WAIT_COUNT=0
              while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
                if ! pm2 list | grep -q iamvet; then
                  echo "‚úÖ PM2 ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä ÏôÑÏ†ÑÌûà Ï§ëÏßÄÎêòÏóàÏäµÎãàÎã§."
                  break
                fi
                echo "ÎåÄÍ∏∞ Ï§ë... ($WAIT_COUNT/$MAX_WAIT Ï¥à)"
                sleep 1
                WAIT_COUNT=$((WAIT_COUNT + 1))
              done
              
              # ÌÉÄÏûÑÏïÑÏõÉ Ï≤¥ÌÅ¨
              if [ $WAIT_COUNT -eq $MAX_WAIT ]; then
                echo "‚ö†Ô∏è Í≤ΩÍ≥†: PM2 ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä 30Ï¥à ÎÇ¥Ïóê Ï§ëÏßÄÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Í∞ïÏ†ú Ï¢ÖÎ£åÎ•º ÏãúÎèÑÌï©ÎãàÎã§."
                pm2 kill 2>/dev/null || true
                sleep 3
                # PM2 Îç∞Î™¨ Ïû¨ÏãúÏûë
                pm2 resurrect 2>/dev/null || true
                pm2 save 2>/dev/null || true
              fi
              
              # Ï∂îÍ∞Ä ÏïàÏ†Ñ ÎåÄÍ∏∞
              sleep 3
            fi
            
            echo "ÏÉà PM2 ÌîÑÎ°úÏÑ∏Ïä§ ÏãúÏûë Ï§ë..."
            # PM2 ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨ ÌõÑ ÏãúÏûë
            pm2 flush || true
            pm2 start ecosystem.config.js
            
            # ÌîÑÎ°úÏÑ∏Ïä§ ÏãúÏûë ÎåÄÍ∏∞
            sleep 15
            
            # PM2 ÏÉÅÌÉú ÌôïÏù∏
            pm2 status
            
            # PM2 Ïû¨Î∂ÄÌåÖ ÌõÑ ÏûêÎèô ÏãúÏûë ÏÑ§Ï†ï (Ìïú Î≤àÎßå ÏÑ§Ï†ï)
            echo "=== Setting up PM2 Startup ==="
            if ! sudo systemctl list-unit-files | grep -q "pm2-ubuntu.service\|pm2-root.service"; then
              echo "PM2 startup ÏÑ§Ï†ï Ï§ë..."
              pm2 startup | grep -v "PM2" | grep -v "To setup" | sudo bash || true
            else
              echo "‚úÖ PM2 startup Ïù¥ÎØ∏ ÏÑ§Ï†ïÎê®"
            fi
            
            # PM2 ÌîÑÎ°úÏÑ∏Ïä§ Î™©Î°ù Ï†ÄÏû• (Ïû¨Î∂ÄÌåÖ ÌõÑ ÏûêÎèô ÏãúÏûë)
            pm2 save
            
            # ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÎäîÏßÄ ÌôïÏù∏
            if pm2 list | grep -q "iamvet.*online"; then
              echo "‚úÖ PM2 ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§."
              # Ï∂îÍ∞Ä ÌôïÏù∏: Ïã§Ï†úÎ°ú ÏÑúÎ≤ÑÍ∞Ä ÏùëÎãµÌïòÎäîÏßÄ ÌÖåÏä§Ìä∏
              sleep 5
              if curl -f http://localhost:3001 > /dev/null 2>&1; then
                echo "‚úÖ Next.js ÏÑúÎ≤ÑÍ∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏùëÎãµÌï©ÎãàÎã§."
              else
                echo "‚ö†Ô∏è Í≤ΩÍ≥†: PM2Îäî Ïã§Ìñâ Ï§ëÏù¥ÏßÄÎßå ÏÑúÎ≤ÑÍ∞Ä ÏùëÎãµÌïòÏßÄ ÏïäÏäµÎãàÎã§."
                pm2 logs iamvet --lines 30 --nostream
              fi
            else
              echo "‚ùå Í≤ΩÍ≥†: PM2 ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."
              pm2 logs iamvet --lines 30 --nostream
              exit 1
            fi
            
            echo "=== Setting up Auto-Recovery System ==="
            
            # ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖú ÏÑ§Ï†ï
            if [ ! -f "/home/ubuntu/iamvet/health-check.sh" ]; then
              echo "ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖú ÏÑ§Ï†ï Ï§ë..."
              
              # Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ± (Í≥ºÎèÑÌïú Ïû¨ÏãúÏûë Î∞©ÏßÄ)
              cat > /home/ubuntu/iamvet/health-check.sh << 'HEALTHCHECK'
            #!/bin/bash
            
            # Next.js ÏÑúÎ≤Ñ Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïä§ÌÅ¨Î¶ΩÌä∏ (Í≥ºÎèÑÌïú Ïû¨ÏãúÏûë Î∞©ÏßÄ)
            MAX_RESPONSE_TIME=5
            RETRY_COUNT=3
            MIN_RESTART_INTERVAL=300  # ÏµúÏÜå Ïû¨ÏãúÏûë Í∞ÑÍ≤© (5Î∂Ñ)
            RESTART_COUNT_FILE="/home/ubuntu/iamvet/logs/restart-count.txt"
            LAST_RESTART_FILE="/home/ubuntu/iamvet/logs/last-restart.txt"
            
            # Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
            mkdir -p /home/ubuntu/iamvet/logs
            
            # Ïû¨ÏãúÏûë ÌöüÏàò Î∞è ÏãúÍ∞Ñ Ï∂îÏ†Å
            get_restart_count() {
                if [ -f "$RESTART_COUNT_FILE" ]; then
                    cat "$RESTART_COUNT_FILE"
                else
                    echo "0"
                fi
            }
            
            get_last_restart_time() {
                if [ -f "$LAST_RESTART_FILE" ]; then
                    cat "$LAST_RESTART_FILE"
                else
                    echo "0"
                fi
            }
            
            update_restart_info() {
                local count=$(get_restart_count)
                echo $((count + 1)) > "$RESTART_COUNT_FILE"
                date +%s > "$LAST_RESTART_FILE"
            }
            
            # Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìñâ
            for i in $(seq 1 $RETRY_COUNT); do
                if curl -f -s --max-time $MAX_RESPONSE_TIME http://localhost:3001 > /dev/null 2>&1; then
                    echo "$(date '+%Y-%m-%d %H:%M:%S'): ‚úÖ Next.js ÏÑúÎ≤Ñ Ï†ïÏÉÅ ÏùëÎãµ"
                    exit 0
                fi
                if [ $i -lt $RETRY_COUNT ]; then
                    echo "$(date '+%Y-%m-%d %H:%M:%S'): ‚ö†Ô∏è ÏãúÎèÑ $i/$RETRY_COUNT Ïã§Ìå®, Ïû¨ÏãúÎèÑ Ï§ë..."
                    sleep 2
                fi
            done
            
            # ÏÑúÎ≤Ñ ÏùëÎãµ ÏóÜÏùå
            echo "$(date '+%Y-%m-%d %H:%M:%S'): ‚ùå Next.js ÏÑúÎ≤Ñ ÏùëÎãµ ÏóÜÏùå"
            
            # ÏµúÍ∑º Ïû¨ÏãúÏûë ÏãúÍ∞Ñ ÌôïÏù∏
            LAST_RESTART=$(get_last_restart_time)
            CURRENT_TIME=$(date +%s)
            TIME_SINCE_LAST_RESTART=$((CURRENT_TIME - LAST_RESTART))
            
            # ÏµúÏÜå Ïû¨ÏãúÏûë Í∞ÑÍ≤© Ï≤¥ÌÅ¨ (Í≥ºÎèÑÌïú Ïû¨ÏãúÏûë Î∞©ÏßÄ)
            if [ $TIME_SINCE_LAST_RESTART -lt $MIN_RESTART_INTERVAL ]; then
                REMAINING_TIME=$((MIN_RESTART_INTERVAL - TIME_SINCE_LAST_RESTART))
                echo "$(date '+%Y-%m-%d %H:%M:%S'): ‚è∏Ô∏è ÏµúÍ∑º Ïû¨ÏãúÏûë ÌõÑ ${TIME_SINCE_LAST_RESTART}Ï¥à Í≤ΩÍ≥º, ÏµúÏÜå Í∞ÑÍ≤©(${MIN_RESTART_INTERVAL}Ï¥à) ÎØ∏Îã¨Î°ú Ïû¨ÏãúÏûë Í±¥ÎÑàÎúÄ (${REMAINING_TIME}Ï¥à ÌõÑ Í∞ÄÎä•)"
                exit 0
            fi
            
            # PM2 Ïû¨ÏãúÏûë
            echo "$(date '+%Y-%m-%d %H:%M:%S'): üîÑ PM2 Ïû¨ÏãúÏûë ÏãúÎèÑ"
            
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
            
            cd /home/ubuntu/iamvet
            pm2 restart iamvet
            
            # Ïû¨ÏãúÏûë Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
            update_restart_info
            RESTART_COUNT=$(get_restart_count)
            
            # Ïû¨ÏãúÏûë ÌõÑ ÌôïÏù∏
            sleep 10
            if curl -f -s --max-time $MAX_RESPONSE_TIME http://localhost:3001 > /dev/null 2>&1; then
                echo "$(date '+%Y-%m-%d %H:%M:%S'): ‚úÖ PM2 Ïû¨ÏãúÏûë ÌõÑ ÏÑúÎ≤Ñ Ï†ïÏÉÅ ÏùëÎãµ (Ï¥ù Ïû¨ÏãúÏûë ÌöüÏàò: ${RESTART_COUNT})"
                exit 0
            else
                echo "$(date '+%Y-%m-%d %H:%M:%S'): ‚ùå PM2 Ïû¨ÏãúÏûë ÌõÑÏóêÎèÑ ÏÑúÎ≤Ñ ÏùëÎãµ ÏóÜÏùå (Ï¥ù Ïû¨ÏãúÏûë ÌöüÏàò: ${RESTART_COUNT})"
                
                # Ïó∞ÏÜç Ïã§Ìå® Ïãú Í≤ΩÍ≥† (5Ìöå Ïù¥ÏÉÅ)
                if [ $RESTART_COUNT -ge 5 ]; then
                    echo "$(date '+%Y-%m-%d %H:%M:%S'): üö® Í≤ΩÍ≥†: Ïû¨ÏãúÏûë ÌöüÏàòÍ∞Ä ${RESTART_COUNT}ÌöåÏóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§. Í∑ºÎ≥∏ ÏõêÏù∏ ÌôïÏù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§."
                fi
                
                exit 1
            fi
            HEALTHCHECK
              
              chmod +x /home/ubuntu/iamvet/health-check.sh
              
              # Cron job ÏÑ§Ï†ï (Í∏∞Ï°¥ Ï†úÍ±∞ ÌõÑ Ï∂îÍ∞Ä)
              crontab -l 2>/dev/null | grep -v "health-check.sh" | crontab - 2>/dev/null || true
              (crontab -l 2>/dev/null; echo "*/5 * * * * /home/ubuntu/iamvet/health-check.sh >> /home/ubuntu/iamvet/logs/health-check.log 2>&1") | crontab -
              
              echo "‚úÖ ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖú ÏÑ§Ï†ï ÏôÑÎ£å"
            else
              echo "‚úÖ ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖú Ïù¥ÎØ∏ ÏÑ§Ï†ïÎê®"
            fi
            
            echo "=== Deployment Complete ==="
          ENDSSH

      - name: Health Check
        run: |
          sleep 10
          # HTTPÏôÄ HTTPS Î™®Îëê ÌôïÏù∏
          curl -f http://${{ secrets.EC2_HOST }} || echo "HTTP check failed, trying HTTPS..."
          curl -f -k https://${{ secrets.EC2_HOST }} || echo "HTTPS check failed"

